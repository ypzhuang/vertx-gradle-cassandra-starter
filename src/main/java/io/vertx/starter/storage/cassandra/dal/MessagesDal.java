package io.vertx.starter.storage.cassandra.dal;

import com.cyngn.vertx.async.ResultContext;
import com.datastax.driver.mapping.MappingManager;
import com.datastax.driver.mapping.Result;
import com.englishtown.vertx.cassandra.CassandraSession;
import com.englishtown.vertx.cassandra.FutureUtils;
import com.englishtown.vertx.cassandra.mapping.VertxMapper;
import com.englishtown.vertx.cassandra.mapping.VertxMappingManager;
import com.englishtown.vertx.cassandra.mapping.impl.DefaultVertxMappingManager;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.ListenableFuture;
import io.vertx.core.Vertx;
import io.vertx.starter.storage.cassandra.table.Messages;
import java.lang.Object;
import java.lang.Override;
import java.lang.Throwable;
import java.lang.Void;
import java.util.List;
import java.util.function.Consumer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * GENERATED CODE DO NOT MODIFY - last updated: 2017-02-20T06:11:58.831Z
 * generated by exovert - https://github.com/cyngn/exovert
 *
 * DAL for Cassandra entity - {@link io.vertx.starter.storage.cassandra.table.Messages}
 */
public class MessagesDal implements CommonDal<Messages> {
  private static final Logger logger = LoggerFactory.getLogger(MessagesDal.class);

  final CassandraSession session;

  final VertxMapper<Messages> mapper;

  final MessagesAccessor accessor;

  final Vertx vertx;

  public MessagesDal(final CassandraSession session) {
    this.session = session;
    VertxMappingManager manager = new DefaultVertxMappingManager(session);
    mapper = manager.mapper(Messages.class);
    MappingManager accessorMappingManager = new MappingManager(session.getSession());
    accessor = accessorMappingManager.createAccessor(MessagesAccessor.class);
    vertx = session.getVertx();
  }

  /**
   * Save a {@link io.vertx.starter.storage.cassandra.table.Messages} object.
   */
  public void save(final Messages messagesObj, final Consumer<ResultContext> onComplete) {
    logger.info("save - {}", messagesObj);

    mapper.saveAsync(messagesObj, new FutureCallback<Void>() {
      @Override
      public void onSuccess(Void result) {
        onComplete.accept(new ResultContext(true));
      }

      @Override
      public void onFailure(Throwable error) {
        logger.error("save - {}, ex: ", messagesObj, error);
        onComplete.accept(new ResultContext(error, "Failed to save Messages: " +  messagesObj));
      }
    });
  }

  /**
   * Delete a {@link io.vertx.starter.storage.cassandra.table.Messages} object.
   */
  public void delete(final Messages messagesObj, final Consumer<ResultContext> onComplete) {
    logger.info("delete - {}", messagesObj);

    mapper.deleteAsync(messagesObj, new FutureCallback<Void>() {
      @Override
      public void onSuccess(Void result) {
        onComplete.accept(new ResultContext(true));
      }

      @Override
      public void onFailure(Throwable error) {
        logger.error("delete - {}, ex: ", messagesObj, error);
        onComplete.accept(new ResultContext(error, "Failed to delete Messages: " +  messagesObj));
      }
    });
  }

  /**
   * Delete a {@link io.vertx.starter.storage.cassandra.table.Messages} object by key.
   */
  public void delete(final Consumer<ResultContext> onComplete, final Object... primaryKey) {
    logger.info("delete - {}", primaryKey);

    mapper.deleteAsync(new FutureCallback<Void>() {
      @Override
      public void onSuccess(Void result) {
        onComplete.accept(new ResultContext(true));
      }

      @Override
      public void onFailure(Throwable error) {
        logger.error("delete - {}, ex: ", primaryKey, error);
        onComplete.accept(new ResultContext(error, "Failed to delete Messages by key: " +  primaryKey));
      }
    }, primaryKey);
  }

  /**
   * Get a {@link io.vertx.starter.storage.cassandra.table.Messages} object by primary key.
   */
  public void get(final Consumer<ResultContext<Messages>> onComplete, final Object... primaryKey) {
    logger.info("get - {}", primaryKey);

    mapper.getAsync(new FutureCallback<Messages>() {
      @Override
      public void onSuccess(Messages result) {
        onComplete.accept(new ResultContext(true, result));
      }

      @Override
      public void onFailure(Throwable error) {
        logger.error("get - {}, ex: ", primaryKey, error);
        onComplete.accept(new ResultContext(error, "Failed to get Messages by key: " +  primaryKey));
      }
    }, primaryKey);
  }

  public void getAll(final Consumer<ResultContext<List<Messages>>> onComplete) {
    logger.info("getAll -");
    ListenableFuture future = accessor.getAll();
    FutureUtils.addCallback(future, new FutureCallback<Result<Messages>>() {
      @Override
      public void onSuccess(Result<Messages> result) {
        onComplete.accept(new ResultContext(true, result.all()));
      }

      @Override
      public void onFailure(Throwable error) {
        logger.error("getAll - ex: ", error);
        onComplete.accept(new ResultContext(error, "Failed to get all."));
      }
    }, vertx);
  }
}
