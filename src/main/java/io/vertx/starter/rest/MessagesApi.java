package io.vertx.starter.rest;

import com.cyngn.vertx.web.HttpHelper;
import com.cyngn.vertx.web.JsonUtil;
import com.cyngn.vertx.web.RestApi;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.ext.web.RoutingContext;
import io.vertx.starter.storage.cassandra.dal.MessagesDal;
import io.vertx.starter.storage.cassandra.table.Messages;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * GENERATED CODE DO NOT MODIFY - last updated: 2017-02-20T06:11:58.831Z
 * generated by exovert - https://github.com/cyngn/exovert
 *
 * REST Api for Cassandra entity - {@link io.vertx.starter.storage.cassandra.table.Messages}
 */
public class MessagesApi implements RestApi {
  private static final Logger logger = LoggerFactory.getLogger(MessagesApi.class);

  public static final String MESSAGES_API = "/api/v1/messages";

  public static final String MESSAGES_ALL_API = "/api/v1/messages_all";

  private final MessagesDal storage;

  private final RestApi.RestApiDescriptor[] supportedApi =  {
    new RestApi.RestApiDescriptor(HttpMethod.POST, MESSAGES_API, this::save),
    new RestApi.RestApiDescriptor(HttpMethod.GET, MESSAGES_API, this::get),
    new RestApi.RestApiDescriptor(HttpMethod.DELETE, MESSAGES_API, this::delete),
    new RestApi.RestApiDescriptor(HttpMethod.GET, MESSAGES_ALL_API, this::getAll)
  };

  final String[] primaryKey;

  public MessagesApi(final MessagesDal storage) {
    this.storage = storage;
    primaryKey = new String[] {
      "id"
    } ;
  }

  /**
   * Save a {@link io.vertx.starter.storage.cassandra.table.Messages} object.
   */
  public void save(final RoutingContext context) {
    HttpServerRequest request = context.request();
    if(request.isEnded()) {
      save(context, context.getBody());
    } else {
      request.bodyHandler(buffer -> save(context, buffer));
    }
  }

  /**
   * Save a {@link io.vertx.starter.storage.cassandra.table.Messages} object.
   *
   * NOTE: this method is left intentionally package protected to allow you to call it in a different way
   */
  void save(final RoutingContext context, final Buffer body) {
    Messages entity = JsonUtil.parseJsonToObject(body.toString(), Messages.class);
    if(entity == null) {
      HttpHelper.processErrorResponse("Failed to parse body: " + body, context.response(), HttpResponseStatus.BAD_REQUEST.code());
      return;
    }

    storage.save(entity, result ->  {
      if(result.succeeded) {
        HttpHelper.processResponse(context.response());
      } else if(result.error != null) {
        String error = "Could not persist " + entity.toString() + ", error: " + result.error.getMessage();
        logger.error("save - {}",  error);
        HttpHelper.processErrorResponse(error, context.response(), HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
      } else {
        String error = "Could not persist " + entity.toString() + ", error: " + result.errorMessage;
        logger.error("save - {}",  error);
        HttpHelper.processErrorResponse(error, context.response(), HttpResponseStatus.BAD_REQUEST.code());
      }
    } );
  }

  /**
   * Delete a {@link io.vertx.starter.storage.cassandra.table.Messages} object.
   */
  public void delete(final RoutingContext context) {
    // if query params aren't valid a HttpResponseStatus.BAD_REQUEST will be sent with the missing field
    Object[] queryKey = null;
    if(RestUtil.isValid(context.request(), primaryKey)) {
      queryKey = convertQueryString(context);
    }

    if(queryKey != null) {
      storage.delete(result ->  {
        if(result.succeeded) {
          HttpHelper.processResponse(context.response());
        } else if (result.error != null) {
          String error = "Could not DELETE with query: " + context.request().uri() + " error: " + result.error.getMessage();
          logger.error("delete - {}",  error);
          HttpHelper.processErrorResponse(error, context.response(), HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
        } else {
          String error = "Could not DELETE with query: " + context.request().uri() + " error: " + result.error.getMessage();
          logger.error("delete - {}", error);
          HttpHelper.processErrorResponse(error, context.response(), HttpResponseStatus.BAD_REQUEST.code());
        }
      } , queryKey);
    }
  }

  /**
   * Get a {@link io.vertx.starter.storage.cassandra.table.Messages} object.
   */
  public void get(final RoutingContext context) {
    // if query params aren't valid a HttpResponseStatus.BAD_REQUEST will be sent with the missing field
    Object[] queryKey = null;
    if(RestUtil.isValid(context.request(), primaryKey)) {
      queryKey = convertQueryString(context);
    }

    if(queryKey != null) {
      storage.get(result ->  {
        if(result.succeeded) {
          if(result.value != null) {
            HttpHelper.processResponse(result.value, context.response());
          } else {
            HttpHelper.processResponse(context.response(), HttpResponseStatus.NOT_FOUND.code());
          }
        } else if(result.error != null) {
          String error = "Could not GET with query: " + context.request().uri() + " error: " + result.error.getMessage();
          logger.error("get - {}",  error);
          HttpHelper.processErrorResponse(error, context.response(), HttpResponseStatus.INTERNAL_SERVER_ERROR.code());
        } else {
          String error = "Could not GET with query: " + context.request().uri() + " error: " + result.error.getMessage();
          logger.error("get - {}", error);
          HttpHelper.processErrorResponse(error, context.response(), HttpResponseStatus.BAD_REQUEST.code());
        }
      } , queryKey);
    }
  }

  /**
   * GetAll - gets a list of a {@link io.vertx.starter.storage.cassandra.table.Messages} object.
   */
  public void getAll(final RoutingContext context) {
    // there's only 1 key so we do a get all
    storage.getAll(result -> RestUtil.processGetAllResult(context, result));
  }

  @Override
  public RestApi.RestApiDescriptor[] supportedApi() {
    return supportedApi;
  }

  /**
   * Convert query params to their Cassandra type.
   */
  public Object[] convertQueryString(final RoutingContext context) {
    HttpServerRequest request = context.request();
    // if query params aren't valid a HttpResponseStatus.BAD_REQUEST will be sent with the missing field
    Object[] values = new Object[1];
    try {
      values[0] = request.getParam("id");
    } catch (Exception ex) {
      HttpHelper.processErrorResponse(ex.getMessage(), context.response(), HttpResponseStatus.BAD_REQUEST.code());
      return null;
    }
    return values;
  }
}
